// Removed direct imports of currency constants (AED, AFN, etc.)
// Removed phf import
// Removed direct imports of currency constants (AED, AFN, etc.)
// Removed phf import
use crate::Money;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::iter::Sum;

// Removed: mod generated; - This will be included in lib.rs

/// Trait defining essential properties for a currency used with Money.
/// This might be simplified or removed if Currency struct is always used directly.
pub trait FormattableCurrency: PartialEq + Eq { // Removed Copy
    fn exponent(&self) -> u32;
    fn code(&self) -> &'static str;
    // Removed locale() method
    fn symbol(&self) -> &'static str;
    fn symbol_first(&self) -> bool;
}

/// Represents a currency, typically defined by ISO 4217 standards or custom ones.
/// Instances are generated by the build script from `data/currencies.json`
/// and accessed via the `generated::CURRENCIES` map.
#[derive(Debug, Eq, Clone, Serialize, Deserialize, Hash, PartialOrd, Ord, Copy)]
pub struct Currency {
    pub code: &'static str,
    pub exponent: u32,
    // pub locale: Locale, // Removed locale field
    pub minor_units: u64,
    pub name: &'static str,
    pub symbol: &'static str,
    pub symbol_first: bool, // Removed duplicate field
}

impl PartialEq<Self> for Currency {
    fn eq(&self, other: &Self) -> bool {
        // Equality is based solely on the currency code
        self.code == other.code
    }
}

// Removed PartialOrd and Ord implementations as they might not be strictly necessary
// and relied on the code field which is already used for PartialEq.
// If ordering is needed later, it can be re-added based on specific requirements.

impl Sum for Money {
    /// Sums an iterator of `Money` objects.
    ///
    /// This implementation adheres to the `std::iter::Sum` trait.
    ///
    /// # Panics
    ///
    /// - Panics with the message "Cannot sum an empty iterator of Money" if the iterator is empty.
    ///   The `Sum` trait requires returning `Self`, and there's no sensible default `Money` value
    ///   (especially currency) to return for an empty set.
    /// - Panics with the message "Cannot sum Money with different currencies" if the iterator
    ///   contains `Money` objects with differing currencies during the summation process.
    ///   This ensures that the resulting sum is always meaningful.
    ///
    /// For non-panicking summation, consider using `Iterator::try_fold` or iterating manually
    /// and handling potential `MoneyError::CurrencyMismatch` from the `Add` operation.
    fn sum<I: Iterator<Item = Self>>(mut iter: I) -> Self {
        let first = iter.next().expect("Cannot sum an empty iterator of Money");
        iter.fold(first, |acc, money| {
            // Add returns Result now, unwrap or panic on currency mismatch
            (acc + money).expect("Cannot sum Money with different currencies")
        })
    }
}

// Default implementation might not be very useful now, consider removing or simplifying.
impl Default for Currency {
    fn default() -> Self {
        // Provides a mostly empty Currency. Useful primarily for placeholder scenarios.
        // Using a known currency like USD might be more practical in some cases.
        Currency {
            code: "",
            exponent: 0,
            // locale: Locale::EnEu, // Removed locale field
            minor_units: 0,
            name: "",
            symbol: "",
            symbol_first: false,
        }
    }
}

// Implement the trait for the Currency struct itself
impl FormattableCurrency for Currency {
    fn exponent(&self) -> u32 {
        self.exponent
    }

    fn code(&self) -> &'static str {
        self.code
    }

    // locale() method removed

    fn symbol(&self) -> &'static str {
        self.symbol // Corrected: return the symbol field
    }

    fn symbol_first(&self) -> bool {
        self.symbol_first // Added missing implementation
    }
}

impl fmt::Display for Currency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.code) // Displaying the code is a reasonable default
    }
}

// Removed the static CURRENCIES map (phf_map).
// The build script now generates `crate::generated::CURRENCIES`.

/// Finds a `Currency` based on its ISO 4217 or other registered code.
///
/// Looks up the code in the `HashMap` generated at compile time by the build script.
/// Returns `None` if the currency code is not found.
pub fn find_currency(code: &str) -> Option<&'static Currency> {
    // Use the map generated by the build script (included directly in lib.rs)
    crate::CURRENCIES.get(code)
}

#[cfg(test)]
mod tests {
    // Import constants directly for tests where specific currencies are needed
    use crate::currencies::crypto::BTC;
    use crate::currencies::iso::{AED, EUR, USD}; // Added EUR import
    use crate::{find_currency, Money};
    // Keep find_currency
    use rust_decimal::Decimal;
    use std::str::FromStr;

    // This test might be less relevant now, as direct comparison uses PartialEq on code.
    // Keeping it to ensure basic access works.
    #[test]
    fn check_basic_currency_properties() {
        // Accessing fields or comparing owned constants directly is fine
        assert_eq!(USD.code, "USD");
        assert_eq!(AED.code, "AED");
        assert_ne!(USD, AED); // Ensure PartialEq works as expected
    }

    #[test]
    fn find_currency_works() {
        // find_currency now returns Option<&'static Currency>
        let found_usd = find_currency("USD").expect("USD should be found");
        assert_eq!(found_usd.code, "USD");
        assert_eq!(found_usd.exponent, 2); // Check a property

        let found_aed = find_currency("AED").expect("AED should be found");
        assert_eq!(found_aed.code, "AED");

        assert!(find_currency("XYZ").is_none()); // Test for non-existent currency
    }

    // Removed find_returns_known_currencies and currency_can_be_accessed_by_reference
    // as they tested the old static map or direct constant access which is less relevant now.
    // The find_currency_works test covers the main lookup functionality.

    #[test]
    fn test_sum() {
        // Money::from_decimal takes Currency by value, so clone the constant.
        let money1 = Money::from_decimal(Decimal::from_str("10.1").unwrap(), USD.clone());
        let money2 = Money::from_decimal(Decimal::from_str("20.2").unwrap(), USD.clone());
        let money3 = Money::from_decimal(Decimal::from_str("30.3").unwrap(), USD.clone());

        let monies = vec![money1, money2, money3];
        // Use the safe Money::sum_iter instead of std::iter::Sum
        let total = Money::sum_iter(monies.into_iter()).unwrap().unwrap(); // Unwrap Result and Option

        assert_eq!(total.amount(), &Decimal::from_str("60.6").unwrap());
        assert_eq!(total.currency(), &USD); // Compare with the constant reference
    }

    // Test the error case for Money::sum_iter
    #[test]
    fn test_sum_iter_errors_on_different_currencies() {
        // Clone constants when creating Money
        let money1 = Money::from_decimal(Decimal::from_str("10.1").unwrap(), USD.clone());
        let money2 = Money::from_decimal(Decimal::from_str("20.2").unwrap(), USD.clone());
        let money3 = Money::from_decimal(Decimal::from_str("30.3").unwrap(), EUR.clone()); // Different currency

        let monies = vec![money1, money2, money3];
        let result = Money::sum_iter(monies.into_iter());
        assert_eq!(result, Err(crate::MoneyError::CurrencyMismatch));
    }

    // Test the empty case for Money::sum_iter
    #[test]
    fn test_sum_iter_empty_iterator() {
        let monies: Vec<Money> = vec![];
        let result = Money::sum_iter(monies.into_iter());
        assert_eq!(result, Ok(None)); // Expect Ok(None) for empty iterator
    }

    // This test still works as it uses the constant directly.
    // Note: BTC won't be found by `find_currency` unless added to data/currencies.json
    // and included in the build script generation.
    #[test]
    fn check_basic_crypto_currency_properties() {
        // Accessing fields on the owned constant is fine
        assert_eq!(BTC.code, "BTC");
        assert_eq!(BTC.exponent, 8);
        assert_eq!(BTC.symbol, "â‚¿");
    }
}
